# EINSTEIN WELLS PROTECTED CONTAINER - MEMORY SHIELDING + TRANSLATION FAULT VALIDATION
FROM node:24-alpine

# Install memory monitoring and protection tools
RUN apk add --no-cache \
    htop \
    procps \
    linux-headers \
    gcc \
    g++ \
    make \
    python3 \
    python3-dev \
    musl-dev \
    && rm -rf /var/cache/apk/*

# Set memory limits and optimization
ENV NODE_OPTIONS="--max-old-space-size=8192 --max-semi-space-size=128 --optimize-for-size"
ENV UV_THREADPOOL_SIZE=128
ENV NODE_ENV=production
ENV PORT=8080

# Memory protection configuration
ENV MEMORY_SHIELD_ENABLED=true
ENV TRANSLATION_FAULT_MONITORING=true
ENV MAX_MEMORY_USAGE=8GB
ENV EMERGENCY_MEMORY_THRESHOLD=7GB

# Set working directory
WORKDIR /app

# Copy package files first for better layer caching
COPY package*.json ./

# Install dependencies with memory optimization
RUN npm ci --only=production --no-audit --no-fund \
    && npm cache clean --force

# Copy application files
COPY . .

# Create monitoring and logging directories
RUN mkdir -p /app/logs /app/monitoring /app/shields

# Create memory protection scripts
RUN cat > /app/shields/memory-shield.js << 'EOF'
/**
 * EINSTEIN WELLS MEMORY PROTECTION SHIELD
 * Monitors and prevents translation fault cascades
 */
const os = require('os');
const fs = require('fs');

class MemoryShield {
  constructor() {
    this.maxMemoryBytes = 8 * 1024 * 1024 * 1024; // 8GB
    this.emergencyThreshold = 7 * 1024 * 1024 * 1024; // 7GB
    this.monitoringInterval = 5000; // 5 seconds
    this.translationFaultCount = 0;
    this.lastMemoryUsage = 0;
  }

  startMonitoring() {
    console.log('ðŸ›¡ï¸  MEMORY SHIELD ACTIVATED');
    setInterval(() => this.checkMemoryStatus(), this.monitoringInterval);
  }

  checkMemoryStatus() {
    const usage = process.memoryUsage();
    const totalMemory = usage.rss + usage.heapUsed + usage.external;
    
    if (totalMemory > this.emergencyThreshold) {
      console.log('ðŸš¨ EMERGENCY MEMORY THRESHOLD REACHED');
      this.triggerEmergencyGC();
    }
    
    if (totalMemory > this.lastMemoryUsage * 1.1) {
      console.log('âš ï¸  Rapid memory growth detected - Running preventive GC');
      global.gc && global.gc();
    }
    
    this.lastMemoryUsage = totalMemory;
    this.logMemoryStatus(usage, totalMemory);
  }

  triggerEmergencyGC() {
    console.log('ðŸ§¹ EMERGENCY GARBAGE COLLECTION');
    if (global.gc) {
      global.gc();
      global.gc(); // Double GC for thorough cleanup
    }
    
    // Force module cache cleanup
    Object.keys(require.cache).forEach(key => {
      if (key.includes('node_modules') && !key.includes('winston')) {
        delete require.cache[key];
      }
    });
  }

  logMemoryStatus(usage, total) {
    const status = {
      timestamp: new Date().toISOString(),
      heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
      heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
      external: Math.round(usage.external / 1024 / 1024),
      rss: Math.round(usage.rss / 1024 / 1024),
      total: Math.round(total / 1024 / 1024),
      memoryShieldStatus: 'ACTIVE'
    };
    
    fs.appendFileSync('/app/logs/memory-shield.log', JSON.stringify(status) + '\n');
  }
}

module.exports = { MemoryShield };
EOF

# Create translation fault validator
RUN cat > /app/shields/translation-fault-validator.js << 'EOF'
/**
 * TRANSLATION FAULT VALIDATION SYSTEM
 * Prevents memory fragmentation and validates operations
 */
const { spawn } = require('child_process');

class TranslationFaultValidator {
  constructor() {
    this.faultThreshold = 1000000; // 1M faults trigger intervention
    this.validationInterval = 10000; // 10 seconds
    this.faultHistory = [];
  }

  startValidation() {
    console.log('ðŸ” TRANSLATION FAULT VALIDATOR ACTIVE');
    setInterval(() => this.validateAndClean(), this.validationInterval);
  }

  validateAndClean() {
    // Container-safe memory validation
    const memInfo = process.memoryUsage();
    const faultRisk = this.calculateFaultRisk(memInfo);
    
    if (faultRisk > 0.7) {
      console.log('ðŸš¨ HIGH TRANSLATION FAULT RISK DETECTED');
      this.performPreventiveCleanup();
    }
    
    this.logFaultStatus(faultRisk);
  }

  calculateFaultRisk(memInfo) {
    const heapRatio = memInfo.heapUsed / memInfo.heapTotal;
    const externalRatio = memInfo.external / (500 * 1024 * 1024); // 500MB baseline
    return Math.max(heapRatio, externalRatio);
  }

  performPreventiveCleanup() {
    console.log('ðŸ§¹ PREVENTIVE TRANSLATION FAULT CLEANUP');
    
    // Force garbage collection
    if (global.gc) global.gc();
    
    // Clear require cache for non-essential modules
    this.cleanRequireCache();
    
    // Defragment memory allocation
    this.defragmentMemory();
  }

  cleanRequireCache() {
    const cacheKeys = Object.keys(require.cache);
    let cleaned = 0;
    
    cacheKeys.forEach(key => {
      if (key.includes('test') || key.includes('example') || key.includes('temp')) {
        delete require.cache[key];
        cleaned++;
      }
    });
    
    console.log(`ðŸ—‘ï¸  Cleaned ${cleaned} cache entries`);
  }

  defragmentMemory() {
    // Create temporary arrays to force memory compaction
    const temp = new Array(1000).fill(null).map(() => new Array(1000));
    temp.length = 0;
    
    if (global.gc) global.gc();
  }

  logFaultStatus(risk) {
    const status = {
      timestamp: new Date().toISOString(),
      translationFaultRisk: risk,
      preventiveAction: risk > 0.7 ? 'CLEANUP_PERFORMED' : 'MONITORING',
      validatorStatus: 'ACTIVE'
    };
    
    require('fs').appendFileSync('/app/logs/translation-faults.log', JSON.stringify(status) + '\n');
  }
}

module.exports = { TranslationFaultValidator };
EOF

# Create protected startup script
RUN cat > /app/protected-start.js << 'EOF'
#!/usr/bin/env node
/**
 * EINSTEIN WELLS PROTECTED STARTUP
 * Memory shields and translation fault validation active
 */
const { MemoryShield } = require('./shields/memory-shield.js');
const { TranslationFaultValidator } = require('./shields/translation-fault-validator.js');

// Enable garbage collection
global.gc = require('vm').runInThisContext('gc');

console.log('ðŸ›¡ï¸  EINSTEIN WELLS PROTECTED CONTAINER STARTING');
console.log('=' .repeat(60));
console.log('ðŸ”‹ Memory Shield: ACTIVE');
console.log('ðŸ” Translation Fault Validator: ACTIVE');
console.log('ðŸ§¹ Garbage Collection: ENABLED');
console.log('âš¡ Memory Limit: 8GB with 7GB emergency threshold');

// Initialize protection systems
const memoryShield = new MemoryShield();
const faultValidator = new TranslationFaultValidator();

// Start protection systems
memoryShield.startMonitoring();
faultValidator.startValidation();

// Start the main application
require('./server.js');

console.log('âœ… PROTECTED EINSTEIN WELLS CONTAINER READY');
console.log('ðŸš¨ All memory protection systems active');
EOF

# Make scripts executable
RUN chmod +x /app/protected-start.js

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S einstein -u 1001 && \
    chown -R einstein:nodejs /app

USER einstein

# Expose port
EXPOSE 8080

# Enhanced health check with memory validation
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD node -e " \
    const http = require('http'); \
    const usage = process.memoryUsage(); \
    if (usage.rss > 7 * 1024 * 1024 * 1024) process.exit(1); \
    http.get('http://localhost:8080/health', (res) => \
      process.exit(res.statusCode === 200 ? 0 : 1) \
    ).on('error', () => process.exit(1))"

# Start with protection systems enabled
CMD ["node", "--expose-gc", "protected-start.js"]