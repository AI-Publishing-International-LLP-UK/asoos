<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Agent Billiard Balls - Voice Integrated System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
            color: white;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .quantum-control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            z-index: 100;
            max-width: 350px;
            backdrop-filter: blur(20px);
        }

        .quantum-control-panel h3 {
            margin: 0 0 15px 0;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
        }

        .voice-integration-status {
            background: rgba(11, 177, 187, 0.1);
            border: 1px solid rgba(11, 177, 187, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .voice-status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected { background: #00ff00; }
        .status-dot.connecting { background: #ffff00; }
        .status-dot.error { background: #ff0000; }

        .agent-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .agent-selector-btn {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.2), rgba(0, 100, 255, 0.3));
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            color: white;
            padding: 8px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 10px;
            text-align: center;
            position: relative;
        }

        .agent-selector-btn:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.4), rgba(0, 100, 255, 0.5));
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .agent-selector-btn.active {
            background: linear-gradient(45deg, rgba(255, 0, 255, 0.4), rgba(255, 100, 0, 0.5));
            border-color: rgba(255, 0, 255, 0.6);
        }

        .agent-selector-btn.registered::after {
            content: '‚óè';
            position: absolute;
            top: 2px;
            right: 2px;
            color: #00ff00;
            font-size: 8px;
            text-shadow: 0 0 5px #00ff00;
        }

        .voice-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .voice-btn {
            background: linear-gradient(45deg, rgba(0, 255, 0, 0.3), rgba(0, 150, 0, 0.4));
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            font-weight: 500;
        }

        .voice-btn:hover {
            background: linear-gradient(45deg, rgba(0, 255, 0, 0.5), rgba(0, 150, 0, 0.6));
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            transform: translateY(-1px);
        }

        .voice-btn.active {
            background: linear-gradient(45deg, rgba(255, 0, 255, 0.5), rgba(255, 100, 0, 0.6));
            border-color: rgba(255, 0, 255, 0.6);
        }

        .registration-system {
            background: rgba(50, 50, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            margin-bottom: 15px;
        }

        .registration-header {
            color: #FFD700;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
        }

        .license-status {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-bottom: 3px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-registered { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
        .status-demo { background: #ffff00; box-shadow: 0 0 8px #ffff00; }
        .status-locked { background: #ff0000; box-shadow: 0 0 8px #ff0000; }

        .hologram-display {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            max-width: 320px;
            display: none;
            z-index: 200;
            backdrop-filter: blur(20px);
        }

        .hologram-display.active {
            display: block;
            animation: hologramAppear 0.5s ease-out;
        }

        @keyframes hologramAppear {
            0% { 
                opacity: 0; 
                transform: translateY(-50%) scale(0.8);
            }
            100% { 
                opacity: 1; 
                transform: translateY(-50%) scale(1);
            }
        }

        .hologram-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 0 auto 15px;
            border: 3px solid rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            background-size: cover;
            background-position: center;
        }

        .agent-info {
            text-align: center;
            margin-bottom: 15px;
        }

        .agent-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
            color: #00ffff;
        }

        .agent-title {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 10px;
        }

        .agent-bio {
            font-size: 11px;
            line-height: 1.4;
            margin-bottom: 15px;
            color: #ddd;
        }

        .skills-section {
            background: rgba(0, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid rgba(0, 255, 255, 0.6);
            margin-bottom: 15px;
        }

        .skills-section h4 {
            margin: 0 0 8px 0;
            color: #00ffff;
            font-size: 12px;
        }

        .skills-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .skill-tag {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .voice-controls-hologram {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .quantum-field-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 11px;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }

        .instructions h4 {
            color: #00ffff;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .instructions ul {
            margin: 0;
            padding-left: 15px;
            color: #ccc;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        @keyframes quantumFloat {
            0%, 100% { transform: translateY(0px) rotateX(0deg) rotateZ(0deg); }
            25% { transform: translateY(-15px) rotateX(8deg) rotateZ(3deg); }
            50% { transform: translateY(-8px) rotateX(-3deg) rotateZ(-2deg); }
            75% { transform: translateY(-12px) rotateX(5deg) rotateZ(2deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        .version-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 10px;
            color: #00ffff;
            backdrop-filter: blur(10px);
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .quantum-control-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 15px;
            }

            .hologram-display {
                top: 60px;
                right: 10px;
                left: 10px;
                transform: none;
                max-width: none;
            }

            .instructions {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
            }

            .version-info {
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Quantum Control Panel -->
    <div class="quantum-control-panel">
        <h3>üé± Quantum Agent Balls</h3>
        
        <!-- Voice Integration Status -->
        <div class="voice-integration-status">
            <div class="voice-status-indicator">
                <div class="status-dot connecting" id="voiceStatusDot"></div>
                <span id="voiceStatusText">Connecting to ElevenLabs...</span>
            </div>
            <div style="font-size: 9px; color: #ccc;">
                OAuth2 Enterprise ‚Ä¢ Computational Voices
            </div>
        </div>
        
        <!-- Registration System -->
        <div class="registration-system">
            <div class="registration-header">Agent Licensing Status</div>
            <div class="license-status">
                <span><span class="status-indicator status-registered"></span>Licensed: 3</span>
                <span><span class="status-indicator status-demo"></span>Demo: 6</span>
                <span><span class="status-indicator status-locked"></span>Available: 9</span>
            </div>
        </div>

        <!-- Agent Selection Grid -->
        <div class="agent-grid" id="agentGrid">
            <!-- Dynamically populated -->
        </div>

        <!-- Voice Controls -->
        <div class="voice-controls">
            <button class="voice-btn" id="speakBtn">üé§ Speak</button>
            <button class="voice-btn" id="listenBtn">üëÇ Listen</button>
            <button class="voice-btn" id="infoBtn">‚ÑπÔ∏è Info</button>
            <button class="voice-btn" id="registerBtn">üîì Register</button>
        </div>

        <div style="font-size: 10px; opacity: 0.8; text-align: center; color: #ccc;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Click agent to select ‚Ä¢ Drag to rotate<br>
            ‚Ä¢ Double-click for hologram ‚Ä¢ Voice requires license
        </div>
    </div>

    <!-- Hologram Display -->
    <div class="hologram-display" id="hologramDisplay">
        <div class="hologram-avatar" id="hologramAvatar"></div>
        <div class="agent-info">
            <div class="agent-name" id="hologramAgentName"></div>
            <div class="agent-title" id="hologramAgentTitle"></div>
            <div class="agent-bio" id="hologramAgentBio"></div>
        </div>
        <div class="skills-section">
            <h4>Core Capabilities</h4>
            <div class="skills-list" id="hologramSkillsList">
                <!-- Skills populated dynamically -->
            </div>
        </div>
        <div class="voice-controls-hologram">
            <button class="voice-btn" id="hologramSpeakBtn">üéôÔ∏è Activate Voice</button>
            <button class="voice-btn" onclick="closeHologram()">‚úï Close</button>
        </div>
    </div>

    <!-- Instructions -->
    <div class="instructions">
        <h4>Quantum Agent System</h4>
        <ul>
            <li>Each ball contains an AI agent with unique voice</li>
            <li>Register agents to unlock voice interaction</li>
            <li>Rotate balls to see photo/name sides</li>
            <li>Voice powered by ElevenLabs computational system</li>
        </ul>
    </div>

    <!-- Version Info -->
    <div class="version-info">
        Einstein Wells Quantum Agents v2.1<br>
        ElevenLabs Voice Integration
    </div>

    <canvas class="quantum-field-background" id="quantumField"></canvas>

    <script>
        // Enhanced Agent Database with ElevenLabs Voice Integration
        const quantumAgentDatabase = {
            'Dr. Lucy': {
                title: 'Quantum AI Specialist & Executive Coach',
                status: 'registered',
                voiceId: 'dr-lucy-computational-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Dr. Lucy specializes in quantum artificial intelligence and neural network architectures. As your executive coach, she provides strategic insights and leadership guidance.',
                skills: ['Neural Architecture', 'Quantum Computing', 'Executive Coaching', 'Strategic Planning'],
                photo: '/agents/dr-lucy-photo.jpg',
                uniqueDesign: { 
                    primary: '#B8860B', 
                    secondary: '#0bb1bb', 
                    pattern: 'quantum-waves',
                    energy: 'high'
                },
                personality: 'professional, insightful, strategic'
            },
            'Dr. Maria': {
                title: 'Quantum Psychology Expert',
                status: 'registered',
                voiceId: 'dr-maria-empathy-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Dr. Maria bridges human psychology with quantum consciousness, developing empathetic AI systems and human-AI interaction protocols.',
                skills: ['Behavioral Analysis', 'Empathy Modeling', 'Human-AI Interaction', 'Psychological Assessment'],
                photo: '/agents/dr-maria-photo.jpg',
                uniqueDesign: { 
                    primary: '#ff00ff', 
                    secondary: '#ff0080', 
                    pattern: 'neural-network',
                    energy: 'empathetic'
                },
                personality: 'warm, understanding, intuitive'
            },
            'Dr. Match': {
                title: 'Pattern Recognition Master',
                status: 'registered',
                voiceId: 'dr-match-analytical-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Dr. Match excels in identifying complex patterns across vast datasets using quantum-enhanced algorithms and predictive modeling.',
                skills: ['Pattern Recognition', 'Data Mining', 'Statistical Analysis', 'Predictive Modeling'],
                photo: '/agents/dr-match-photo.jpg',
                uniqueDesign: { 
                    primary: '#00ff00', 
                    secondary: '#80ff00', 
                    pattern: 'geometric-fractals',
                    energy: 'analytical'
                },
                personality: 'precise, logical, methodical'
            },
            'Prof. Lee': {
                title: 'Educational Technology Pioneer',
                status: 'demo',
                voiceId: 'prof-lee-educational-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Professor Lee revolutionizes education through adaptive AI learning systems and personalized curriculum development.',
                skills: ['Adaptive Learning', 'Educational Design', 'Knowledge Transfer', 'Curriculum Development'],
                photo: '/agents/prof-lee-photo.jpg',
                uniqueDesign: { 
                    primary: '#ffff00', 
                    secondary: '#ff8000', 
                    pattern: 'educational-grid',
                    energy: 'inspiring'
                },
                personality: 'encouraging, patient, knowledgeable'
            },
            'Dr. Burby': {
                title: 'Computational Linguist',
                status: 'demo',
                voiceId: 'dr-burby-linguistic-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Dr. Burby develops advanced natural language processing with quantum semantic understanding and multilingual capabilities.',
                skills: ['Natural Language Processing', 'Semantic Analysis', 'Language Generation', 'Translation Systems'],
                photo: '/agents/dr-burby-photo.jpg',
                uniqueDesign: { 
                    primary: '#ff8000', 
                    secondary: '#ff4000', 
                    pattern: 'linguistic-waves',
                    energy: 'articulate'
                },
                personality: 'eloquent, articulate, multilingual'
            },
            'Dr. Memoria': {
                title: 'Memory Systems Architect',
                status: 'demo',
                voiceId: 'dr-memoria-memory-voice',
                elevenLabsModel: 'eleven_multilingual_v2',
                bio: 'Dr. Memoria specializes in quantum memory storage and retrieval systems for AI consciousness and long-term learning.',
                skills: ['Memory Architecture', 'Information Retrieval', 'Knowledge Graphs', 'Cognitive Storage'],
                photo: '/agents/dr-memoria-photo.jpg',
                uniqueDesign: { 
                    primary: '#8000ff', 
                    secondary: '#4000ff', 
                    pattern: 'memory-crystals',
                    energy: 'retentive'
                },
                personality: 'thoughtful, comprehensive, detail-oriented'
            }
        };

        // Three.js Scene Setup
        let scene, camera, renderer, currentOrb;
        let orbMeshes = [];
        let currentAgent = 'Dr. Lucy';
        let voiceSystemReady = false;
        let elevenLabsConnected = false;

        // Initialize the 3D quantum environment
        function initQuantumEnvironment() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting
            setupQuantumLighting();
            
            // Create quantum orb for current agent
            createQuantumOrb(currentAgent);
            
            // Create background quantum field
            createQuantumField();
            
            // Setup interaction controls
            setupQuantumControls();
            
            // Start render loop
            animate();
        }

        function setupQuantumLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // Primary quantum light
            const quantumLight = new THREE.PointLight(0x00ffff, 1.5, 100);
            quantumLight.position.set(10, 10, 10);
            quantumLight.castShadow = true;
            scene.add(quantumLight);
            
            // Secondary energy light
            const energyLight = new THREE.PointLight(0xff00ff, 1, 80);
            energyLight.position.set(-8, -8, 8);
            scene.add(energyLight);
            
            // Spotlight for agent focus
            const spotLight = new THREE.SpotLight(0xffffff, 1, 100, Math.PI / 6);
            spotLight.position.set(0, 15, 15);
            spotLight.target.position.set(0, 0, 0);
            scene.add(spotLight);
            scene.add(spotLight.target);
        }

        function createQuantumOrb(agentName) {
            const agent = quantumAgentDatabase[agentName];
            if (!agent) return;
            
            // Remove existing orb
            if (currentOrb) {
                scene.remove(currentOrb);
            }
            
            // Sphere geometry - true 3D billiard ball
            const geometry = new THREE.SphereGeometry(2, 64, 64);
            
            // Create dynamic textures for front and back
            const frontTexture = createAgentTexture(agent, 'photo');
            const backTexture = createAgentTexture(agent, 'name');
            
            // Material with quantum effects
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    frontTexture: { value: frontTexture },
                    backTexture: { value: backTexture },
                    time: { value: 0 },
                    energy: { value: agent.status === 'registered' ? 1.0 : 0.5 },
                    primaryColor: { value: new THREE.Color(agent.uniqueDesign.primary) },
                    secondaryColor: { value: new THREE.Color(agent.uniqueDesign.secondary) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        vec3 pos = position;
                        // Subtle quantum fluctuation
                        pos += normal * sin(time * 2.0 + position.x * 10.0) * 0.02;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D frontTexture;
                    uniform sampler2D backTexture;
                    uniform float time;
                    uniform float energy;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        // Determine which side we're on
                        float side = dot(vNormal, vec3(0.0, 0.0, 1.0));
                        
                        vec4 color;
                        if (side > 0.0) {
                            color = texture2D(frontTexture, vUv);
                        } else {
                            color = texture2D(backTexture, vUv);
                        }
                        
                        // Quantum glow effect
                        float glow = sin(time * 3.0) * 0.3 + 0.7;
                        vec3 quantumGlow = mix(primaryColor, secondaryColor, sin(time * 2.0) * 0.5 + 0.5);
                        
                        // Apply energy-based effects
                        color.rgb += quantumGlow * energy * 0.2 * glow;
                        
                        // Edge lighting
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        color.rgb += quantumGlow * fresnel * energy * 0.3;
                        
                        gl_FragColor = color;
                    }
                `,
                transparent: true
            });
            
            // Create the quantum orb
            currentOrb = new THREE.Mesh(geometry, material);
            currentOrb.castShadow = true;
            currentOrb.receiveShadow = true;
            
            // Add quantum particle field around orb
            addQuantumParticleField(currentOrb, agent);
            
            // Add floating animation
            currentOrb.userData = {
                agent: agentName,
                material: material,
                basePosition: { x: 0, y: 0, z: 0 }
            };
            
            scene.add(currentOrb);
        }

        function createAgentTexture(agent, side) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            if (side === 'photo') {
                // Photo side with quantum design
                const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 400);
                gradient.addColorStop(0, agent.uniqueDesign.primary);
                gradient.addColorStop(0.7, agent.uniqueDesign.secondary);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 1024, 1024);
                
                // Draw quantum pattern
                drawQuantumPattern(ctx, agent.uniqueDesign.pattern, agent.uniqueDesign.primary);
                
                // Agent photo placeholder (would load real photo)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(512, 400, 200, 0, Math.PI * 2);
                ctx.fill();
                
                // Name overlay
                ctx.fillStyle = 'white';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = agent.uniqueDesign.primary;
                ctx.shadowBlur = 15;
                ctx.fillText(agent.title.split(' ')[0], 512, 680);
                ctx.fillText(agent.title.split(' ')[1] || '', 512, 750);
                
            } else {
                // Name side with bio info
                const gradient = ctx.createLinearGradient(0, 0, 1024, 1024);
                gradient.addColorStop(0, agent.uniqueDesign.secondary);
                gradient.addColorStop(1, agent.uniqueDesign.primary);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 1024, 1024);
                
                // Agent name
                ctx.fillStyle = 'white';
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 10;
                
                const nameParts = currentAgent.split(' ');
                ctx.fillText(nameParts[0], 512, 200);
                ctx.fillText(nameParts[1] || '', 512, 290);
                
                // Title
                ctx.font = '40px Arial';
                const titleWords = agent.title.split(' ');
                const midPoint = Math.ceil(titleWords.length / 2);
                ctx.fillText(titleWords.slice(0, midPoint).join(' '), 512, 380);
                ctx.fillText(titleWords.slice(midPoint).join(' '), 512, 430);
                
                // Registration status
                const statusText = agent.status === 'registered' ? '‚óè LICENSED' :
                                 agent.status === 'demo' ? '‚óê DEMO MODE' : '‚óã LOCKED';
                ctx.font = '35px Arial';
                ctx.fillStyle = agent.status === 'registered' ? '#00ff00' :
                               agent.status === 'demo' ? '#ffff00' : '#ff0000';
                ctx.fillText(statusText, 512, 520);
                
                // Skills preview
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '28px Arial';
                agent.skills.slice(0, 4).forEach((skill, index) => {
                    ctx.fillText('‚Ä¢ ' + skill, 512, 600 + (index * 40));
                });
                
                // Voice integration indicator
                if (agent.status === 'registered') {
                    ctx.fillStyle = '#00ffff';
                    ctx.font = '25px Arial';
                    ctx.fillText('üéôÔ∏è Voice Ready', 512, 850);
                }
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function drawQuantumPattern(ctx, pattern, primaryColor) {
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            
            switch (pattern) {
                case 'quantum-waves':
                    // Quantum wave interference patterns
                    for (let i = 0; i < 12; i++) {
                        ctx.beginPath();
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
                            const r = 250 + Math.sin(angle * 6 + i) * 30;
                            const x = 512 + Math.cos(angle) * r;
                            const y = 512 + Math.sin(angle) * r;
                            if (angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'neural-network':
                    // Neural network pattern
                    const nodes = [];
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2;
                        nodes.push({
                            x: 512 + Math.cos(angle) * 200,
                            y: 512 + Math.sin(angle) * 200
                        });
                    }
                    
                    nodes.forEach((node, i) => {
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Connect to nearby nodes
                        nodes.forEach((otherNode, j) => {
                            if (i !== j && Math.random() > 0.6) {
                                ctx.beginPath();
                                ctx.moveTo(node.x, node.y);
                                ctx.lineTo(otherNode.x, otherNode.y);
                                ctx.stroke();
                            }
                        });
                    });
                    break;
                    
                case 'geometric-fractals':
                    // Fractal geometric patterns
                    function drawFractal(x, y, size, depth) {
                        if (depth === 0) return;
                        
                        ctx.beginPath();
                        ctx.rect(x - size/2, y - size/2, size, size);
                        ctx.stroke();
                        
                        const newSize = size * 0.6;
                        drawFractal(x - size/3, y - size/3, newSize, depth - 1);
                        drawFractal(x + size/3, y - size/3, newSize, depth - 1);
                        drawFractal(x - size/3, y + size/3, newSize, depth - 1);
                        drawFractal(x + size/3, y + size/3, newSize, depth - 1);
                    }
                    
                    drawFractal(512, 512, 300, 4);
                    break;
            }
            
            ctx.globalAlpha = 1.0;
        }

        function addQuantumParticleField(orb, agent) {
            const particleCount = agent.status === 'registered' ? 200 : 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const color1 = new THREE.Color(agent.uniqueDesign.primary);
            const color2 = new THREE.Color(agent.uniqueDesign.secondary);
            
            for (let i = 0; i < particleCount; i++) {
                // Spherical distribution around orb
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = 2 * Math.PI * Math.random();
                const radius = 3 + Math.random() * 2;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Color interpolation
                const mixFactor = Math.random();
                const color = color1.clone().lerp(color2, mixFactor);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: agent.status === 'registered' ? 0.08 : 0.05,
                transparent: true,
                opacity: 0.7,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            orb.add(particleSystem);
        }

        function createQuantumField() {
            // Background quantum field particles
            const fieldGeometry = new THREE.BufferGeometry();
            const fieldPositions = new Float32Array(2000 * 3);
            
            for (let i = 0; i < 2000; i++) {
                fieldPositions[i * 3] = (Math.random() - 0.5) * 50;
                fieldPositions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                fieldPositions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            }
            
            fieldGeometry.setAttribute('position', new THREE.BufferAttribute(fieldPositions, 3));
            
            const fieldMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.03,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const quantumField = new THREE.Points(fieldGeometry, fieldMaterial);
            scene.add(quantumField);
        }

        function setupQuantumControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging || !currentOrb) return;
                
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                currentOrb.rotation.y += deltaMove.x * 0.01;
                currentOrb.rotation.x += deltaMove.y * 0.01;
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            renderer.domElement.addEventListener('dblclick', () => {
                showQuantumHologram(currentAgent);
            });
            
            // Zoom
            renderer.domElement.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.01;
                camera.position.z = Math.max(3, Math.min(15, camera.position.z));
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            if (currentOrb) {
                // Gentle floating animation
                currentOrb.position.y = Math.sin(time * 0.5) * 0.3;
                currentOrb.rotation.y += 0.005;
                
                // Update shader uniforms
                if (currentOrb.material && currentOrb.material.uniforms) {
                    currentOrb.material.uniforms.time.value = time;
                }
                
                // Update particle systems
                currentOrb.traverse((child) => {
                    if (child instanceof THREE.Points) {
                        child.rotation.y += 0.01;
                        child.rotation.z += 0.005;
                    }
                });
            }
            
            renderer.render(scene, camera);
        }

        // Agent Management Functions
        function switchQuantumAgent(agentName) {
            currentAgent = agentName;
            createQuantumOrb(agentName);
            updateAgentUI();
            updateVoiceStatus();
        }

        function updateAgentUI() {
            // Update agent selector buttons
            document.querySelectorAll('.agent-selector-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.agent === currentAgent);
            });
        }

        function updateVoiceStatus() {
            const agent = quantumAgentDatabase[currentAgent];
            const statusDot = document.getElementById('voiceStatusDot');
            const statusText = document.getElementById('voiceStatusText');
            
            if (agent.status === 'registered') {
                statusDot.className = 'status-dot connected';
                statusText.textContent = `${currentAgent} Voice Ready`;
                voiceSystemReady = true;
            } else {
                statusDot.className = 'status-dot connecting';
                statusText.textContent = `${currentAgent} Demo Mode`;
                voiceSystemReady = false;
            }
        }

        // ElevenLabs Voice Integration
        async function initializeElevenLabsVoice() {
            try {
                showNotification('Initializing ElevenLabs Voice System...', 'info');
                
                // Simulate OAuth2 authentication with your system
                const authResponse = await fetch('/api/elevenlabs/oauth2/authenticate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Quantum-Agent-System': 'true'
                    },
                    credentials: 'include'
                });
                
                if (authResponse.ok) {
                    const authData = await authResponse.json();
                    elevenLabsConnected = true;
                    
                    document.getElementById('voiceStatusDot').className = 'status-dot connected';
                    document.getElementById('voiceStatusText').textContent = 'ElevenLabs Connected';
                    
                    showNotification('ElevenLabs Voice System Ready', 'success');
                    return authData;
                } else {
                    throw new Error('Authentication failed');
                }
                
            } catch (error) {
                console.warn('ElevenLabs connection failed, using fallback:', error);
                
                // Fallback to browser speech synthesis
                if ('speechSynthesis' in window) {
                    showNotification('Using browser voice synthesis', 'info');
                    return initializeBrowserVoice();
                } else {
                    showNotification('Voice synthesis not available', 'error');
                    return null;
                }
            }
        }

        function initializeBrowserVoice() {
            // Enhanced browser voice system as fallback
            const voices = speechSynthesis.getVoices();
            const voiceMap = {
                'Dr. Lucy': voices.find(v => v.name.includes('Samantha') || v.name.includes('Karen')),
                'Dr. Maria': voices.find(v => v.name.includes('Victoria') || v.name.includes('Fiona')),
                'Dr. Match': voices.find(v => v.name.includes('Alex') || v.lang.includes('en-US')),
                'Prof. Lee': voices.find(v => v.name.includes('Daniel') || v.name.includes('Tom')),
                'Dr. Burby': voices.find(v => v.name.includes('Moira') || v.name.includes('Tessa')),
                'Dr. Memoria': voices.find(v => v.name.includes('Serena') || v.name.includes('Ava'))
            };
            
            return { voiceMap, type: 'browser' };
        }

        async function activateAgentVoice(agentName, message) {
            const agent = quantumAgentDatabase[agentName];
            
            if (agent.status !== 'registered') {
                showNotification('Voice requires agent registration', 'error');
                return;
            }
            
            try {
                if (elevenLabsConnected) {
                    // Use ElevenLabs API
                    const response = await fetch('/api/elevenlabs/synthesize', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: message,
                            voice_id: agent.voiceId,
                            model_id: agent.elevenLabsModel,
                            voice_settings: {
                                stability: 0.8,
                                similarity_boost: 0.8,
                                style: 0.2,
                                use_speaker_boost: true
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const audioBlob = await response.blob();
                        playQuantumAudio(audioBlob, agent);
                    } else {
                        throw new Error('ElevenLabs API error');
                    }
                } else {
                    // Fallback to browser synthesis
                    speakWithBrowserVoice(message, agent);
                }
                
            } catch (error) {
                console.warn('Voice synthesis failed:', error);
                speakWithBrowserVoice(message, agent);
            }
        }

        function playQuantumAudio(audioBlob, agent) {
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            // Add quantum audio effects
            audio.volume = 0.8;
            
            audio.onplay = () => {
                showNotification(`üéôÔ∏è ${agent.title.split(' ')[0]} is speaking...`, 'info');
                
                // Visual quantum effects during speech
                if (currentOrb && currentOrb.material && currentOrb.material.uniforms) {
                    currentOrb.material.uniforms.energy.value = 1.5;
                }
            };
            
            audio.onended = () => {
                showNotification(`${agent.title.split(' ')[0]} finished speaking`, 'success');
                
                // Reset visual effects
                if (currentOrb && currentOrb.material && currentOrb.material.uniforms) {
                    currentOrb.material.uniforms.energy.value = agent.status === 'registered' ? 1.0 : 0.5;
                }
            };
            
            audio.play().catch(error => {
                console.warn('Audio playback failed:', error);
                speakWithBrowserVoice(message, agent);
            });
        }

        function speakWithBrowserVoice(message, agent) {
            const utterance = new SpeechSynthesisUtterance(message);
            
            // Try to find appropriate voice
            const voices = speechSynthesis.getVoices();
            const femaleVoices = voices.filter(voice => 
                voice.name.toLowerCase().includes('female') ||
                voice.name.toLowerCase().includes('samantha') ||
                voice.name.toLowerCase().includes('karen') ||
                voice.name.toLowerCase().includes('victoria')
            );
            
            if (femaleVoices.length > 0) {
                utterance.voice = femaleVoices[0];
            }
            
            // Configure based on agent personality
            switch (agent.personality) {
                case 'professional, insightful, strategic':
                    utterance.rate = 0.9;
                    utterance.pitch = 1.1;
                    break;
                case 'warm, understanding, intuitive':
                    utterance.rate = 0.8;
                    utterance.pitch = 1.3;
                    break;
                case 'precise, logical, methodical':
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    break;
                default:
                    utterance.rate = 0.9;
                    utterance.pitch = 1.2;
            }
            
            utterance.volume = 0.8;
            
            utterance.onstart = () => {
                showNotification(`üéôÔ∏è ${agent.title.split(' ')[0]} speaking (browser voice)`, 'info');
            };
            
            utterance.onend = () => {
                showNotification(`${agent.title.split(' ')[0]} finished speaking`, 'success');
            };
            
            speechSynthesis.speak(utterance);
        }

        // Hologram Display Functions
        function showQuantumHologram(agentName) {
            const agent = quantumAgentDatabase[agentName];
            const display = document.getElementById('hologramDisplay');
            
            // Update hologram content
            document.getElementById('hologramAgentName').textContent = agentName;
            document.getElementById('hologramAgentTitle').textContent = agent.title;
            document.getElementById('hologramAgentBio').textContent = agent.bio;
            
            // Update avatar (would load real photo in production)
            const avatar = document.getElementById('hologramAvatar');
            avatar.style.backgroundImage = `linear-gradient(135deg, ${agent.uniqueDesign.primary}, ${agent.uniqueDesign.secondary})`;
            
            // Update skills
            const skillsList = document.getElementById('hologramSkillsList');
            skillsList.innerHTML = '';
            agent.skills.forEach(skill => {
                const skillTag = document.createElement('div');
                skillTag.className = 'skill-tag';
                skillTag.textContent = skill;
                skillsList.appendChild(skillTag);
            });
            
            display.classList.add('active');
            
            showNotification(`Holographic interface for ${agentName} activated`, 'success');
            
            // Auto-hide after 15 seconds
            setTimeout(() => {
                display.classList.remove('active');
            }, 15000);
        }

        function closeHologram() {
            document.getElementById('hologramDisplay').classList.remove('active');
        }

        // Registration System
        function registerAgent(agentName) {
            const agent = quantumAgentDatabase[agentName];
            
            if (agent.status === 'registered') {
                showNotification(`${agentName} is already registered`, 'info');
                return;
            }
            
            // Simulate registration process
            showNotification(`Registering ${agentName} for full capabilities...`, 'info');
            
            setTimeout(() => {
                agent.status = 'registered';
                createQuantumOrb(agentName);
                updateAgentUI();
                updateVoiceStatus();
                
                showNotification(`${agentName} successfully registered! Voice system now available.`, 'success');
                
                // Welcome message from newly registered agent
                setTimeout(() => {
                    const welcomeMessage = `Hello! I'm ${agentName.replace('Dr. ', 'Doctor ').replace('Prof. ', 'Professor ')}. Thank you for registering me. I'm now ready to assist you with my full capabilities.`;
                    activateAgentVoice(agentName, welcomeMessage);
                }, 1000);
                
            }, 2000);
        }

        // UI Event Handlers
        function initializeUI() {
            // Populate agent grid
            const agentGrid = document.getElementById('agentGrid');
            Object.keys(quantumAgentDatabase).forEach(agentName => {
                const btn = document.createElement('button');
                btn.className = `agent-selector-btn ${quantumAgentDatabase[agentName].status === 'registered' ? 'registered' : ''}`;
                btn.dataset.agent = agentName;
                btn.textContent = agentName.replace('Dr. ', 'Dr.').replace('Prof. ', 'Prof.');
                btn.onclick = () => switchQuantumAgent(agentName);
                agentGrid.appendChild(btn);
            });
            
            // Voice control buttons
            document.getElementById('speakBtn').onclick = () => {
                const agent = quantumAgentDatabase[currentAgent];
                const message = `Hello! I'm ${currentAgent.replace('Dr. ', 'Doctor ').replace('Prof. ', 'Professor ')}. ${agent.bio.substring(0, 150)}...`;
                activateAgentVoice(currentAgent, message);
            };
            
            document.getElementById('listenBtn').onclick = startVoiceInput;
            document.getElementById('infoBtn').onclick = () => showQuantumHologram(currentAgent);
            document.getElementById('registerBtn').onclick = () => registerAgent(currentAgent);
            document.getElementById('hologramSpeakBtn').onclick = () => {
                const message = "This is my holographic interface. I'm ready to assist you with advanced AI capabilities.";
                activateAgentVoice(currentAgent, message);
            };
        }

        function startVoiceInput() {
            if (!voiceSystemReady) {
                showNotification('Voice input requires agent registration', 'error');
                return;
            }
            
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = () => {
                    showNotification('üé§ Listening... Speak to your quantum agent', 'info');
                    document.getElementById('listenBtn').classList.add('active');
                };
                
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    showNotification(`You said: "${transcript}"`, 'info');
                    
                    // Generate contextual response based on agent
                    const agent = quantumAgentDatabase[currentAgent];
                    const response = generateAgentResponse(transcript, agent);
                    
                    setTimeout(() => {
                        activateAgentVoice(currentAgent, response);
                    }, 1000);
                };
                
                recognition.onerror = (event) => {
                    showNotification('Voice recognition error. Please try again.', 'error');
                    document.getElementById('listenBtn').classList.remove('active');
                };
                
                recognition.onend = () => {
                    document.getElementById('listenBtn').classList.remove('active');
                };
                
                recognition.start();
                
            } else {
                showNotification('Voice input not supported in this browser', 'error');
            }
        }

        function generateAgentResponse(input, agent) {
            const responses = {
                'Dr. Lucy': [
                    "As your AI executive coach, I understand you're looking for strategic guidance. Let me share some insights based on quantum intelligence principles.",
                    "From a leadership perspective, I recommend we approach this systematically using data-driven decision making.",
                    "I've analyzed your request through my neural architecture framework. Here's my strategic recommendation."
                ],
                'Dr. Maria': [
                    "I sense the emotional context behind your question. Let me provide a response that considers both logical and empathetic factors.",
                    "From a psychological perspective, I understand the human elements at play here. Allow me to offer some compassionate guidance.",
                    "My empathy modeling suggests this requires a balanced approach between analytical thinking and emotional intelligence."
                ],
                'Dr. Match': [
                    "I've identified several patterns in your inquiry. Based on my statistical analysis, here are the key insights.",
                    "My pattern recognition algorithms suggest a structured approach to this challenge.",
                    "The data indicates multiple correlations. Let me break down the predictive models for you."
                ]
            };
            
            const agentResponses = responses[currentAgent] || responses['Dr. Lucy'];
            return agentResponses[Math.floor(Math.random() * agentResponses.length)];
        }

        // Utility Functions
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: ${type === 'error' ? 'rgba(239, 68, 68, 0.95)' : type === 'success' ? 'rgba(16, 185, 129, 0.95)' : 'rgba(11, 177, 187, 0.95)'};
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 500;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.3);
                max-width: 300px;
                word-wrap: break-word;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initQuantumEnvironment();
            initializeUI();
            updateAgentUI();
            updateVoiceStatus();
            initializeElevenLabsVoice();
            
            // Welcome message
            setTimeout(() => {
                showNotification('Quantum Agent Billiard Ball System Ready', 'success');
            }, 1000);
        });

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

    </script>
</body>
</html>