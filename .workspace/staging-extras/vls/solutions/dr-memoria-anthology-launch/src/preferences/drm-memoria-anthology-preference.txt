"""
User Preference Learning module for Dr. Memoria's Anthology system.
Learns user preferences from content performance and feedback.
"""

import logging
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime

from models import CreativeWork, ContentType, WorkStatus, UserPreference

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class UserPreferenceLearner:
    """Learns user preferences from content performance and feedback"""
    
    def __init__(
        self,
        analytics_engine: 'AnalyticsEngine',
        user_preferences: Dict[str, UserPreference] = None
    ):
        self.analytics_engine = analytics_engine
        self.user_preferences = user_preferences or {}
    
    async def learn_from_performance(
        self,
        work: CreativeWork,
        performance_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Learn preferences from content performance
        
        Args:
            work: The work that was published
            performance_data: Performance analytics for the work
            
        Returns:
            Dict with updated preference insights
        """
        user_id = work.owner_id
        
        # Create user preference if it doesn't exist
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = UserPreference(user_id=user_id)
        
        user_pref = self.user_preferences[user_id]
        
        # Extract insights from performance data
        insights = {
            "content_type_performance": {},
            "platform_performance": {},
            "timing_insights": {},
            "style_insights": {},
            "preference_updates": {}
        }
        
        # Analyze content type performance
        if work.content_type:
            content_type = work.content_type.value
            
            # Update content type preferences
            if content_type not in user_pref.content_preferences:
                user_pref.content_preferences[content_type] = {
                    "performance_score": 0,
                    "sample_count": 0,
                    "last_performance": None
                }
            
            # Calculate performance score
            performance_score = self._calculate_performance_score(performance_data)
            
            # Update running average
            current = user_pref.content_preferences[content_type]
            total_score = current["performance_score"] * current["sample_count"]
            new_count = current["sample_count"] + 1
            new_avg = (total_score + performance_score) / new_count
            
            # Update preferences
            user_pref.content_preferences[content_type]["performance_score"] = new_avg
            user_pref.content_preferences[content_type]["sample_count"] = new_count
            user_pref.content_preferences[content_type]["last_performance"] = performance_score
            
            # Add to insights
            insights["content_type_performance"][content_type] = {
                "current_score": performance_score,
                "average_score": new_avg,
                "sample_count": new_count
            }
            
            insights["preference_updates"]["content_type"] = {
                "type": content_type,
                "score": new_avg
            }
        
        # Analyze platform performance
        if "platform_performance" in performance_data:
            for platform, platform_data in performance_data["platform_performance"].items():
                # Initialize platform in preferences if needed
                if platform not in user_pref.platform_preferences:
                    user_pref.platform_preferences[platform] = {
                        "performance_score": 0,
                        "sample_count": 0,
                        "optimal_posting_times": [],
                        "content_type_performance": {}
                    }
                
                # Calculate platform performance score
                platform_score = self._calculate_platform_score(platform_data)
                
                # Update running average
                current = user_pref.platform_preferences[platform]
                total_score = current["performance_score"] * current["sample_count"]
                new_count = current["sample_count"] + 1
                new_avg = (total_score + platform_score) / new_count
                
                # Update preferences
                user_pref.platform_preferences[platform]["performance_score"] = new_avg
                user_pref.platform_preferences[platform]["sample_count"] = new_count
                
                # Track content type performance on this platform
                if work.content_type:
                    content_type = work.content_type.value
                    if content_type not in user_pref.platform_preferences[platform]["content_type_performance"]:
                        user_pref.platform_preferences[platform]["content_type_performance"][content_type] = {
                            "score": 0,
                            "count": 0
                        }
                    
                    # Update content type score for this platform
                    platform_content = user_pref.platform_preferences[platform]["content_type_performance"][content_type]
                    platform_content["score"] = (platform_content["score"] * platform_content["count"] + platform_score) / (platform_content["count"] + 1)
                    platform_content["count"] += 1
                
                # Add to insights
                insights["platform_performance"][platform] = {
                    "current_score": platform_score,
                    "average_score": new_avg,
                    "sample_count": new_count
                }
                
                insights["preference_updates"]["platform"] = {
                    "platform": platform,
                    "score": new_avg
                }
        
        # Analyze timing insights
        if "publications" in work.metadata:
            for platform, pub_data in work.metadata["publications"].items():
                if "timestamp" in pub_data:
                    try:
                        pub_time = datetime.fromisoformat(pub_data["timestamp"])
                        hour = pub_time.hour
                        
                        # Initialize schedule preferences if needed
                        if "schedule_preferences" not in user_pref.platform_preferences.get(platform, {}):
                            if platform not in user_pref.platform_preferences:
                                user_pref.platform_preferences[platform] = {}
                            
                            user_pref.platform_preferences[platform]["schedule_preferences"] = {
                                "hour_performance": {},
                                "preferred_hours": []
                            }
                        
                        # Get performance for this platform
                        platform_score = 0
                        if platform in performance_data.get("platform_performance", {}):
                            platform_score = self._calculate_platform_score(
                                performance_data["platform_performance"][platform]
                            )
                        
                        # Update hour performance
                        schedule_prefs = user_pref.platform_preferences[platform]["schedule_preferences"]
                        
                        if str(hour) not in schedule_prefs["hour_performance"]:
                            schedule_prefs["hour_performance"][str(hour)] = {
                                "score": 0,
                                "count": 0
                            }
                        
                        hour_perf = schedule_prefs["hour_performance"][str(hour)]
                        hour_perf["score"] = (hour_perf["score"] * hour_perf["count"] + platform_score) / (hour_perf["count"] + 1)
                        hour_perf["count"] += 1
                        
                        # Update preferred hours (top 3)
                        hour_scores = [(int(h), data["score"]) for h, data in schedule_prefs["hour_performance"].items()]
                        top_hours = sorted(hour_scores, key=lambda x: x[1], reverse=True)[:3]
                        schedule_prefs["preferred_hours"] = [h for h, _ in top_hours]
                        
                        # Add to insights
                        if "timing_insights" not in insights:
                            insights["timing_insights"] = {}
                        
                        if platform not in insights["timing_insights"]:
                            insights["timing_insights"][platform] = {}
                        
                        insights["timing_insights"][platform][hour] = {
                            "score": hour_perf["score"],
                            "count": hour_perf["count"]
                        }
                        
                        insights["preference_updates"]["timing"] = {
                            "platform": platform,
                            "preferred_hours": schedule_prefs["preferred_hours"]
                        }
                        
                    except (ValueError, TypeError):
                        pass
        
        # Update user preference timestamp
        user_pref.updated_at = datetime.now()
        
        return insights
    
    async def process_explicit_feedback(
        self,
        user_id: str,
        feedback: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Process explicit user feedback to update preferences
        
        Args:
            user_id: User ID to update preferences for
            feedback: Feedback data
            
        Returns:
            Dict with updated preference insights
        """
        # Create user preference if it doesn't exist
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = UserPreference(user_id=user_id)
        
        user_pref = self.user_preferences[user_id]
        updates = {}
        
        # Process content type preferences
        if "content_type_preferences" in feedback:
            for content_type, score in feedback["content_type_preferences"].items():
                if content_type not in user_pref.content_preferences:
                    user_pref.content_preferences[content_type] = {
                        "performance_score": 0,
                        "sample_count": 0,
                        "user_preference": None
                    }
                
                # Update user preference
                user_pref.content_preferences[content_type]["user_preference"] = score
                
                # Add to updates
                if "content_type" not in updates:
                    updates["content_type"] = {}
                
                updates["content_type"][content_type] = score
        
        # Process platform preferences
        if "platform_preferences" in feedback:
            for platform, platform_data in feedback["platform_preferences"].items():
                if platform not in user_pref.platform_preferences:
                    user_pref.platform_preferences[platform] = {}
                
                # Update platform preferences
                for key, value in platform_data.items():
                    user_pref.platform_preferences[platform][key] = value
                
                # Add to updates
                if "platform" not in updates:
                    updates["platform"] = {}
                
                updates["platform"][platform] = platform_data
        
        # Process style preferences
        if "style_preferences" in feedback:
            user_pref.style_preferences.update(feedback["style_preferences"])
            updates["style"] = feedback["style_preferences"]
        
        # Process schedule preferences
        if "schedule_preferences" in feedback:
            for platform, schedule_data in feedback["schedule_preferences"].items():
                if platform not in user_pref.platform_preferences:
                    user_pref.platform_preferences[platform] = {}
                
                if "schedule_preferences" not in user_pref.platform_preferences[platform]:
                    user_pref.platform_preferences[platform]["schedule_preferences"] = {}
                
                # Update schedule preferences
                user_pref.platform_preferences[platform]["schedule_preferences"].update(schedule_data)
                
                # Add to updates
                if "schedule" not in updates:
                    updates["schedule"] = {}
                
                updates["schedule"][platform] = schedule_data
        
        # Update user preference timestamp
        user_pref.updated_at = datetime.now()
        
        return {
            "user_id": user_id,
            "updates": updates
        }
    
    def _calculate_performance_score(self, performance_data: Dict[str, Any]) -> float:
        """Calculate overall performance score from analytics data"""
        # Simple scoring based on engagement rate
        if "overall_engagement_rate" in performance_data:
            # Scale engagement rate to 0-100 score
            return min(100, performance_data["overall_engagement_rate"] * 20)
        
        # If no overall rate, average platform rates
        elif "platform_performance" in performance_data:
            platform_scores = []
            for platform, data in performance_data["platform_performance"].items():
                if "engagement_rate" in data:
                    platform_scores.append(data["engagement_rate"])
            
            if platform_scores:
                avg_rate = sum(platform_scores) / len(platform_scores)
                return min(100, avg_rate * 20)
        
        # Default score if no engagement data
        return 50.0
    
    def _calculate_platform_score(self, platform_data: Dict[str, Any]) -> float:
        """Calculate platform-specific performance score"""
        # Simple scoring based on engagement rate
        if "engagement_rate" in platform_data:
            # Scale engagement rate to 0-100 score
            return min(100, platform_data["engagement_rate"] * 20)
        
        # Default score if no engagement data
        return 50.0
    
    def get_user_preferences(self, user_id: str) -> Optional[UserPreference]:
        """Get user preferences by ID"""
        return self.user_preferences.get(user_id)
    
    def get_content_recommendations(
        self,
        user_id: str
    ) -> Dict[str, Any]:
        """
        Get content recommendations based on user preferences
        
        Args:
            user_id: User ID to get recommendations for
            
        Returns:
            Dict with content recommendations
        """
        user_pref = self.get_user_preferences(user_id)
        if not user_pref:
            return {
                "user_id": user_id,
                "error": "No preferences found for user"
            }
        
        recommendations = {
            "user_id": user_id,
            "recommended_content_types": [],
            "recommended_platforms": [],
            "optimal_posting_times": {},
            "style_recommendations": {}
        }
        
        # Recommend content types
        content_scores = []
        for content_type, data in user_pref.content_preferences.items():
            # Prefer user-specified preferences if available
            if "user_preference" in data and data["user_preference"] is not None:
                score = data["user_preference"]
            else:
                score = data.get("performance_score", 0)
            
            content_scores.append((content_type, score))
        
        # Sort by score
        sorted_content = sorted(content_scores, key=lambda x: x[1], reverse=True)
        recommendations["recommended_content_types"] = [
            {"type": ct, "score": score} for ct, score in sorted_content[:3]
        ]
        
        # Recommend platforms
        platform_scores = []
        for platform, data in user_pref.platform_preferences.items():
            score = data.get("performance_score", 0)
            platform_scores.append((platform, score))
        
        # Sort by score
        sorted_platforms = sorted(platform_scores, key=lambda x: x[1], reverse=True)
        recommendations["recommended_platforms"] = [
            {"platform": p, "score": score} for p, score in sorted_platforms[:3]
        ]
        
        # Get optimal posting times
        for platform, data in user_pref.platform_preferences.items():
            if "schedule_preferences" in data and "preferred_hours" in data["schedule_preferences"]:
                preferred_hours = data["schedule_preferences"]["preferred_hours"]
                if preferred_hours:
                    recommendations["optimal_posting_times"][platform] = preferred_hours
        
        # Style recommendations
        if user_pref.style_preferences:
            recommendations["style_recommendations"] = user_pref.style_preferences
        
        return recommendations
